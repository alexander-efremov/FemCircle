#include <math.h>#include <stdio.h>#include <string.h>#include <float.h>#include "consts.h"#include "timer.h"#include "utils.h"#include "common.h"//#include "omp.h"using namespace std;inline void print_data_to_files(double *phi, double *density, double *residual, double* coef, int tl) {    print_surface("phi", NX, NY, HX, HY, tl, A, C, get_center_x(), get_center_y(), TAU,                  U, V, phi);    print_surface("rho", NX, NY, HX, HY, tl, A, C, get_center_x(), get_center_y(), TAU,                  U, V, density);    print_surface("coef", NX, NY, HX, HY, tl, A, C, get_center_x(), get_center_y(), TAU,                  U, V, coef);//    print_surface("res", NX, NY, HX, HY, tl, A, C, get_center_x(), get_center_y(), TAU,//                  U, V, residual);    double *err_lock = calc_error_5(HX, HY, tl * TAU, density);    print_surface("err-l", NX, NY, HX, HY, tl, A, C, get_center_x(), get_center_y(),                  TAU, U, V, err_lock);    delete[] err_lock;}inline static double func_u(double t, double x, double y) { return U; }inline static double func_v(double t, double x, double y) { return V; }inline static double analytical_solution_circle(double t, double x, double y) {    double x0 = get_center_x() + t * func_u(t, x, y);    double y0 = get_center_y() + t * func_v(t, x, y);    double value = (x - x0) * (x - x0) + (y - y0) * (y - y0);    if (value <= R_SQ) return INN_DENSITY;    return OUT_DENSITY;}static void coef_calculate(int ii, int jj, double *density,                           double *coef) {    int key = NY_1 * ii + jj;    double real_integral_value = 0;    double part = 0.25;    double integ = (density[ii * NY_1 + jj]                    + density[(ii + 1) * NY_1 + jj]                    + density[(ii + 1) * NY_1 + jj + 1]                    + density[ii * NY_1 + jj + 1]);    real_integral_value = HX * HY * part * integ;    double k;    if (coef[key] != 0) {        k = real_integral_value / coef[key];    }    else {        printf("ALARM! coef[%d] = 0", key);        k = 0.;    }    coef[key] = k;}static void coef_fill(int ii, int jj, double *density, double time_value,                      double *coef) {    double x1 = 0.;    double y1 = 0.;    double x2 = 0.;    double y2 = 0.;    double x3 = 0.;    double y3 = 0.;    double x4 = 0.;    double y4 = 0.;    get_coordinates_on_curr(ii, jj, x1, y1, x2, y2, x3, y3, x4, y4);//    printf("POINT: %d   %d :  x1=%.8le * y1=%.8le ** x2=%.8le * y2=%.8le ** x3=%.8le * y3=%.8le **//                   x4=%.8le * y4=%.8le\n", ii,jj, x1,y1, x2,y2, x3,y3, x4,y4);    double u = func_u(time_value, x1, y1);    double v = func_v(time_value, x1, y1);    x1 = x1 - TAU * u;    y1 = y1 - TAU * v;    u = func_u(time_value, x2, y2);    v = func_v(time_value, x2, y2);    x2 = x2 - TAU * u;    y2 = y2 - TAU * v;    u = func_u(time_value, x3, y3);    v = func_v(time_value, x3, y3);    x3 = x3 - TAU * u;    y3 = y3 - TAU * v;    u = func_u(time_value, x4, y4);    v = func_v(time_value, x4, y4);    x4 = x4 - TAU * u;    y4 = y4 - TAU * v;    /*     if (x1 <= A || x1 >= B || x2 <= A || x2 >= B || x3 <= A || x3 >= B || x4 <= A || x4 >= B        || y1 <= C || y1 >= D || y2 <= C || y2 >= D || y3 <= C || y3 >= D || y4 <= C || y4 >= D)        printf("PREV Time level %.8le! ERROR INDEX i=%d j=%d : x1=%.8le * y1=%.8le ** x2=%.8le * y2=%.8le ** x3=%.8le * y3=%.8le ** "                       "x4=%.8le * y4=%.8le\n ", time_value, ii, jj, x1, y1, x2, y2, x3, y3, x4, y4);*/    int nx = IDEAL_SQ_SIZE_X;    int ny = IDEAL_SQ_SIZE_Y;    double x_step = 1. / nx;    double y_step = 1. / ny;    // get right part for jakoby    double mes = x_step * y_step;    for (int i = 0; i < nx; ++i) {        for (int j = 0; j < ny; ++j) {            double ideal_x = i * x_step + x_step / 2.;            double ideal_y = j * y_step + y_step / 2.;            double a11 = (x2 - x1) + (x1 + x3 - x2 - x4) * ideal_y;            double a12 = (x4 - x1) + (x1 + x3 - x2 - x4) * ideal_x;            double a21 = (y2 - y1) + (y1 + y3 - y2 - y4) * ideal_y;            double a22 = (y4 - y1) + (y1 + y3 - y2 - y4) * ideal_x;            double jakob = a11 * a22 - a21 * a12;            double real_x = x1 + (x2 - x1) * ideal_x + (x4 - x1) * ideal_y                            + (x1 + x3 - x2 - x4) * ideal_x * ideal_y;            double real_y = y1 + (y2 - y1) * ideal_x + (y4 - y1) * ideal_y                            + (y1 + y3 - y2 - y4) * ideal_x * ideal_y;            // find out in which square real point was placed            int sq_i = (int) (((real_x - A) + FLT_MIN) / HX);            int sq_j = (int) (((real_y - C) + FLT_MIN) / HY);            double x = A + sq_i * HX;            double y = C + sq_j * HY;            // formula 4            double dens = density[sq_i * NY_1 + sq_j] * (1 - (real_x - x) / HX) * (1 - (real_y - y) / HY)                          + density[(sq_i + 1) * NY_1 + sq_j] * ((real_x - x) / HX) * (1 - (real_y - y) / HY)                          + density[(sq_i + 1) * NY_1 + sq_j + 1] * ((real_x - x) / HX) * ((real_y - y) / HY)                          + density[sq_i * NY_1 + sq_j + 1] * (1 - (real_x - x) / HX) * ((real_y - y) / HY);            int mapIndex = NY_1 * sq_i + sq_j;            coef[mapIndex] += mes * dens * jakob;        }    }}static double get_phi_integ_midpoint(int ii, int jj, double *density, double time_value) {    double x1 = 0.;    double y1 = 0.;    double x2 = 0.;    double y2 = 0.;    double x3 = 0.;    double y3 = 0.;    double x4 = 0.;    double y4 = 0.;    get_coordinates_on_curr(ii, jj, x1, y1, x2, y2, x3, y3, x4, y4);//    printf("POINT: %d   %d :  x1=%.8le * y1=%.8le ** x2=%.8le * y2=%.8le ** x3=%.8le * y3=%.8le **//                   x4=%.8le * y4=%.8le\n", ii,jj, x1,y1, x2,y2, x3,y3, x4,y4);    double u = func_u(time_value, x1, y1);    double v = func_v(time_value, x1, y1);    x1 = x1 - TAU * u;    y1 = y1 - TAU * v;    u = func_u(time_value, x2, y2);    v = func_v(time_value, x2, y2);    x2 = x2 - TAU * u;    y2 = y2 - TAU * v;    u = func_u(time_value, x3, y3);    v = func_v(time_value, x3, y3);    x3 = x3 - TAU * u;    y3 = y3 - TAU * v;    u = func_u(time_value, x4, y4);    v = func_v(time_value, x4, y4);    x4 = x4 - TAU * u;    y4 = y4 - TAU * v;    /*     if (x1 <= A || x1 >= B || x2 <= A || x2 >= B || x3 <= A || x3 >= B || x4 <= A || x4 >= B        || y1 <= C || y1 >= D || y2 <= C || y2 >= D || y3 <= C || y3 >= D || y4 <= C || y4 >= D)        printf("PREV Time level %.8le! ERROR INDEX i=%d j=%d : x1=%.8le * y1=%.8le ** x2=%.8le * y2=%.8le ** x3=%.8le * y3=%.8le ** "                       "x4=%.8le * y4=%.8le\n ", time_value, ii, jj, x1, y1, x2, y2, x3, y3, x4, y4);*/    int nx = IDEAL_SQ_SIZE_X;    int ny = IDEAL_SQ_SIZE_Y;    double x_step = 1. / nx;    double y_step = 1. / ny;    // get right part for jakoby    double phi = 0.;    double mes = x_step * y_step;    for (int i = 0; i < nx; ++i) {        for (int j = 0; j < ny; ++j) {            double ideal_x = i * x_step + x_step / 2.;            double ideal_y = j * y_step + y_step / 2.;            double real_x = x1 + (x2 - x1) * ideal_x + (x4 - x1) * ideal_y                            + (x1 + x3 - x2 - x4) * ideal_x * ideal_y;            double real_y = y1 + (y2 - y1) * ideal_x + (y4 - y1) * ideal_y                            + (y1 + y3 - y2 - y4) * ideal_x * ideal_y;            // find out in which square real point was placed            int sq_i = (int) (((real_x - A) + FLT_MIN) / HX);            int sq_j = (int) (((real_y - C) + FLT_MIN) / HY);            double x = A + sq_i * HX;            double y = C + sq_j * HY;            double a11 = (x2 - x1) + (x1 + x3 - x2 - x4) * ideal_y;            double a12 = (x4 - x1) + (x1 + x3 - x2 - x4) * ideal_x;            double a21 = (y2 - y1) + (y1 + y3 - y2 - y4) * ideal_y;            double a22 = (y4 - y1) + (y1 + y3 - y2 - y4) * ideal_x;            double jakob = a11 * a22 - a21 * a12;            // formula 4            double dens = density[sq_i * NY_1 + sq_j] * (1 - (real_x - x) / HX) * (1 - (real_y - y) / HY)                          + density[(sq_i + 1) * NY_1 + sq_j] * ((real_x - x) / HX) * (1 - (real_y - y) / HY)                          + density[(sq_i + 1) * NY_1 + sq_j + 1] * ((real_x - x) / HX) * ((real_y - y) / HY)                          + density[sq_i * NY_1 + sq_j + 1] * (1 - (real_x - x) / HX) * ((real_y - y) / HY);            phi += mes * dens * jakob;        }    }    if (fabs(phi) < fabs(DBL_MIN_TRIM)) phi = 0;    return phi;}static double integrate(int ii, int jj, double *density, double time_value,                        double *coef) {    double x1 = 0.;    double y1 = 0.;    double x2 = 0.;    double y2 = 0.;    double x3 = 0.;    double y3 = 0.;    double x4 = 0.;    double y4 = 0.;    get_coordinates_on_curr(ii, jj, x1, y1, x2, y2, x3, y3, x4, y4);//    printf("POINT: %d   %d :  x1=%.8le * y1=%.8le ** x2=%.8le * y2=%.8le ** x3=%.8le * y3=%.8le **//                   x4=%.8le * y4=%.8le\n", ii,jj, x1,y1, x2,y2, x3,y3, x4,y4);    double u = func_u(time_value, x1, y1);    double v = func_v(time_value, x1, y1);    x1 = x1 - TAU * u;    y1 = y1 - TAU * v;    u = func_u(time_value, x2, y2);    v = func_v(time_value, x2, y2);    x2 = x2 - TAU * u;    y2 = y2 - TAU * v;    u = func_u(time_value, x3, y3);    v = func_v(time_value, x3, y3);    x3 = x3 - TAU * u;    y3 = y3 - TAU * v;    u = func_u(time_value, x4, y4);    v = func_v(time_value, x4, y4);    x4 = x4 - TAU * u;    y4 = y4 - TAU * v;    /*     if (x1 <= A || x1 >= B || x2 <= A || x2 >= B || x3 <= A || x3 >= B || x4 <= A || x4 >= B        || y1 <= C || y1 >= D || y2 <= C || y2 >= D || y3 <= C || y3 >= D || y4 <= C || y4 >= D)        printf("PREV Time level %.8le! ERROR INDEX i=%d j=%d : x1=%.8le * y1=%.8le ** x2=%.8le * y2=%.8le ** x3=%.8le * y3=%.8le ** "                       "x4=%.8le * y4=%.8le\n ", time_value, ii, jj, x1, y1, x2, y2, x3, y3, x4, y4);    */    int nx = IDEAL_SQ_SIZE_X;    int ny = IDEAL_SQ_SIZE_Y;    double x_step = 1. / nx;    double y_step = 1. / ny;    // get right part for jakoby    double phi = 0.;    double mes = x_step * y_step;    for (int i = 0; i < nx; ++i) {        for (int j = 0; j < ny; ++j) {            double ideal_x = i * x_step + x_step / 2.;            double ideal_y = j * y_step + y_step / 2.;            double real_x = x1 + (x2 - x1) * ideal_x + (x4 - x1) * ideal_y                            + (x1 + x3 - x2 - x4) * ideal_x * ideal_y;            double real_y = y1 + (y2 - y1) * ideal_x + (y4 - y1) * ideal_y                            + (y1 + y3 - y2 - y4) * ideal_x * ideal_y;            // find out in which square real point was placed            int sq_i = (int) (((real_x - A) + FLT_MIN) / HX);            int sq_j = (int) (((real_y - C) + FLT_MIN) / HY);            double x = A + sq_i * HX;            double y = C + sq_j * HY;            double a11 = (x2 - x1) + (x1 + x3 - x2 - x4) * ideal_y;            double a12 = (x4 - x1) + (x1 + x3 - x2 - x4) * ideal_x;            double a21 = (y2 - y1) + (y1 + y3 - y2 - y4) * ideal_y;            double a22 = (y4 - y1) + (y1 + y3 - y2 - y4) * ideal_x;            double jakob = a11 * a22 - a21 * a12;            // formula 4            double dens = density[sq_i * NY_1 + sq_j] * (1 - (real_x - x) / HX) * (1 - (real_y - y) / HY)                          + density[(sq_i + 1) * NY_1 + sq_j] * ((real_x - x) / HX) * (1 - (real_y - y) / HY)                          + density[(sq_i + 1) * NY_1 + sq_j + 1] * ((real_x - x) / HX) * ((real_y - y) / HY)                          + density[sq_i * NY_1 + sq_j + 1] * (1 - (real_x - x) / HX) * ((real_y - y) / HY);            int key = NY_1 * sq_i + sq_j;            double k = coef[key];            phi += mes * dens * jakob * k;        }    }    if (fabs(phi) < fabs(DBL_MIN_TRIM)) phi = 0;    return phi;}double *solve_5(double &tme) {    StartTimer();    fflush(stdout);    int ic = 0;    double *phi = new double[XY];    double *prev_density = new double[XY];    double *density = new double[XY];    double *residual = new double[XY];    double *coef = new double[XY];    //<editor-fold desc="Fill initial data">    for (int i = 0; i < NX_1; ++i) {        for (int j = 0; j < NY_1; ++j) {            density[NY_1 * i + j] = 0.;            prev_density[NY_1 * i + j] = 0.;            residual[NY_1 * i + j] = 0.;            phi[NY_1 * i + j] = 0.;        }    }    // G1 -- (x_i, 0=C) -- bottom boundary    for (int i = 0; i < NX_1; ++i) {        prev_density[NY_1 * i] = analytical_solution_circle(0., A + HX * i, C);        if (fabs(prev_density[NY_1 * i]) < fabs(DBL_MIN_TRIM)) prev_density[NY_1 * i] = 0;    }    // G2 -- (NX=B, y_j) -- right boundary    for (int j = 1; j < NY; ++j) {        prev_density[NY_1 * NX + j] = analytical_solution_circle(0., A + HX * NX, C + HY * j);        if (fabs(prev_density[NY_1 * NX + j]) < fabs(DBL_MIN_TRIM)) prev_density[NY_1 * NX + j] = 0;    }    // G3 -- (x_i, NY=D) -- top boundary    for (int i = 0; i < NX_1; ++i) {        prev_density[NY_1 * i + NY] = analytical_solution_circle(0., A + HX * i, C + HY * NY);        if (fabs(prev_density[NY_1 * i + NY]) < fabs(DBL_MIN_TRIM)) prev_density[NY_1 * i + NY] = 0;    }    // G4 -- (0=A, y_j) -- left boundary    for (int j = 1; j < NY; ++j) {        prev_density[j] = analytical_solution_circle(0., A, C + HY * j);        if (fabs(prev_density[j]) < fabs(DBL_MIN_TRIM)) prev_density[j] = 0;    }    memcpy(density, prev_density, XY * sizeof(double));    // inner points    for (int i = 1; i < NX; ++i) {        for (int j = 1; j < NY; ++j) {            prev_density[NY_1 * i + j] = analytical_solution_circle(0., A + HX * i, C + HY * j);            //if (fabs(prev_density[NY_1 * i + j]) < fabs(DBL_MIN_TRIM)) prev_density[NY_1 * i + j] = 0;        }    }    //</editor-fold>    printf("SUM RHO INIT = %le\n", calc_array_sum(prev_density, NX_1, NY_1, 0));    printf("SUM ABS RHO INIT= %le\n", calc_array_sum(prev_density, NX_1, NY_1, 1));    fflush(stdout);    double *extrems;    double *extrems_err;    double *err;    double l1_err_vec;    double l1_err_tr;    for (int tl = 1; tl <= TIME_STEP_CNT; tl++) {        for (int k = 0; k < XY; ++k) coef[k] = 0.;        //<editor-fold desc="Calculate phi">        //<editor-fold desc="Integrate to get filled coefs">        // G1 -- (x_i, 0=C) -- bottom boundary        for (int i = 1; i < NX; ++i) {            if (G1[i] == 1) {                coef_fill(i, 0, prev_density, TAU * tl, coef);            }        }        // G2 -- (NX=B, y_j) -- right boundary        for (int j = 1; j < NY; ++j) {            if (G2[j] == 1) {                coef_fill(NX, j, prev_density, TAU * tl, coef);            }        }        // G3 -- (x_i, NY=D) -- upper boundary        for (int i = 1; i < NX; ++i) {            if (G3[i] == 1) {                coef_fill(i, NY, prev_density, TAU * tl, coef);            }        }        // G4 -- (0=A, y_j) -- left boundary        for (int j = 1; j < NY; ++j) {            if (G4[j] == 1) {                coef_fill(0, j, prev_density, TAU * tl, coef);            }        }        // point (0.0)        if (CP00 == 1) {            coef_fill(0, 0, prev_density, TAU * tl, coef);        }        // point (1.0)        if (CP10 == 1) {            coef_fill(NX, 0, prev_density, TAU * tl, coef);        }        // point (0.1)        if (CP01 == 1) {            coef_fill(0, NY, prev_density, TAU * tl, coef);        }        // point (1,1)        if (CP11 == 1) {            coef_fill(NX, NY, prev_density, TAU * tl, coef);        }        // inner points        for (int i = 1; i < NX; ++i) {            for (int j = 1; j < NY; ++j) {                coef_fill(i, j, prev_density, TAU * tl, coef);            }        }        //</editor-fold>        //<editor-fold desc="Calculate coefs">//#pragma omp parallel for collapse(2)        for (int i = 0; i < NX; ++i) {            for (int j = 0; j < NY; ++j) {                coef_calculate(i, j, prev_density, coef);            }        }        //</editor-fold>        //<editor-fold desc="Integrate to get phi">        // G1 -- (x_i, 0=C) -- bottom boundary        for (int i = 1; i < NX; ++i) {            if (G1[i] == 1) {                phi[NY_1 * i] = integrate(i, 0, prev_density, TAU * tl, coef);            }        }        // G2 -- (NX=B, y_j) -- right boundary        for (int j = 1; j < NY; ++j) {            if (G2[j] == 1) {                phi[NY_1 * NX + j] = integrate(NX, j, prev_density, TAU * tl, coef);            }        }        // G3 -- (x_i, NY=D) -- upper boundary        for (int i = 1; i < NX; ++i) {            if (G3[i] == 1) {                phi[NY_1 * i + NY] = integrate(i, NY, prev_density, TAU * tl, coef);            }        }        // G4 -- (0=A, y_j) -- left boundary        for (int j = 1; j < NY; ++j) {            if (G4[j] == 1) {                phi[j] = integrate(0, j, prev_density, TAU * tl, coef);            }        }        // point (0.0)        if (CP00 == 1) {            phi[0] = integrate(0, 0, prev_density, TAU * tl, coef);        }        // point (1.0)        if (CP10 == 1) {            phi[NY_1 * NX] = integrate(NX, 0, prev_density, TAU * tl, coef);        }        // point (0.1)        if (CP01 == 1) {            phi[NY] = integrate(0, NY, prev_density, TAU * tl, coef);        }        // point (1,1)        if (CP11 == 1) {            phi[NY_1 * NX + NY] = integrate(NX, NY, prev_density, TAU * tl, coef);        }        // inner points        for (int i = 1; i < NX; ++i) {            for (int j = 1; j < NY; ++j) {                phi[NY_1 * i + j] = integrate(i, j, prev_density, TAU * tl, coef);            }        }//        print_surface("phi1", NX, NY, HX, HY, tl, A, C, get_center_x(), get_center_y(), TAU,//                      U, V, phi);        //</editor-fold>        //</editor-fold>        // G1 -- (x_i, 0=C) -- bottom boundary        double rpCoef = 2. / (HX * HY);        for (int i = 1; i < NX; ++i) {            if (G1[i] == 1) {                density[NY_1 * i] = rpCoef * phi[NY_1 * i];                if (fabs(density[NY_1 * i]) < fabs(DBL_MIN_TRIM)) density[NY_1 * i] = 0;            }        }        // G2 -- (NX=B, y_j) -- right boundary        for (int j = 1; j < NY; ++j) {            if (G2[j] == 1) {                density[NY_1 * NX + j] = rpCoef * phi[NY_1 * NX + j];                if (fabs(density[NY_1 * NX + j]) < fabs(DBL_MIN_TRIM)) density[NY_1 * NX + j] = 0;            }        }        // G3 -- (x_i, NY=D) -- top boundary        for (int i = 1; i < NX; ++i) {            if (G3[i] == 1) {                density[NY_1 * i + NY] = rpCoef * phi[NY_1 * i + NY];                if (fabs(density[NY_1 * i + NY]) < fabs(DBL_MIN_TRIM)) density[NY_1 * i + NY] = 0;            }        }        // G4 -- (0=A, y_j) -- left boundary        for (int j = 1; j < NY; ++j) {            if (G4[j] == 1) { // проверить коэф-ты                density[j] = rpCoef * phi[j];                if (fabs(density[j]) < fabs(DBL_MIN_TRIM)) density[j] = 0;            }        }        rpCoef = 4. / (HX * HY);        // point (0,0)        if (CP00 == 1) {            density[0] = phi[0];            if (fabs(density[0]) < fabs(DBL_MIN_TRIM)) density[0] = 0;        }        // point (1,0)        if (CP10 == 1) {            density[NY_1 * NX] = rpCoef * phi[NY_1 * NX];            if (fabs(density[NY_1 * NX]) < fabs(DBL_MIN_TRIM))                density[NY_1 * NX] = 0;        }        // point (0,1)        if (CP01 == 1) {            density[NY] = rpCoef * phi[NY];            if (fabs(density[NY]) < fabs(DBL_MIN_TRIM))                density[NY] = 0;        }        // point (1,1)        if (CP11 == 1) {            density[NY_1 * NX + NY] = rpCoef * phi[NY_1 * NX + NY];            if (fabs(density[NY_1 * NX + NY]) < fabs(DBL_MIN_TRIM))                density[NY_1 * NX + NY] = 0;        }        rpCoef = 1. / (HX * HY);        for (int i = 1; i < NX; ++i) {            for (int j = 1; j < NY; ++j) {                density[NY_1 * i + j] = rpCoef * phi[NY_1 * i + j];                if (fabs(density[NY_1 * i + j]) < fabs(DBL_MIN_TRIM)) density[NY_1 * i + j] = 0;            }        }        memcpy(prev_density, density, XY * sizeof(double));        if (tl % 10 == 0) {            err = calc_error_5(HX, HY, TAU * tl, density);            l1_err_vec = get_l1_norm_vec(NX_1, NY_1, err);            l1_err_tr = get_l1_norm_int_trapezoidal(HX, HY, NX, NY, err); // note! a loop boundary            extrems = calc_array_extrems(density, NX_1, NY_1);            extrems_err = calc_array_extrems(err, NX_1, NY_1);            printf("tl = %d Sum(Rho)= %le  ERR_VEC= %le  ERR_TR= %le  MAX_RHO= %le"                           "  MAX_ERR= %le\n", tl, calc_array_sum(density, NX_1, NY_1, 0),                   l1_err_vec, l1_err_tr, extrems[1], extrems_err[1]);            fflush(stdout);        }        if (tl % 10 == 0) {            print_data_to_files(phi, density, residual, coef, tl);            int fixed_x = (int) (get_center_x() / HX);            int fixed_y = (int) (get_center_y() / HY);            print_line_along_x("rho", NX, NY, HX, HY, tl, A, C, get_center_x(), get_center_y(), TAU,                               U, V, density, fixed_y);            print_line_along_y("rho", NX, NY, HX, HY, tl, A, C, get_center_x(), get_center_y(), TAU,                               U, V, density, fixed_x);        }    } // time loop    err = calc_error_5(HX, HY, TAU * TIME_STEP_CNT, density);    l1_err_vec = get_l1_norm_vec(NX_1, NY_1, err);    l1_err_tr = get_l1_norm_int_trapezoidal(HX, HY, NX, NY, err); // note! a loop boundary    extrems = calc_array_extrems(density, NX_1, NY_1);    extrems_err = calc_array_extrems(err, NX_1, NY_1);    append_statistics_expl(NX_1, NY_1, TAU, l1_err_vec, l1_err_tr, extrems,                           extrems_err, TIME_STEP_CNT);    delete[] prev_density;    delete[] phi;    delete[] err;    delete[] residual;    delete[] extrems;    delete[] extrems_err;    delete coef;    tme = GetTimer() / 1000;    return density;}double *calc_error_5(double hx, double hy, double tt, double *solution) {    double *res = new double[XY];    for (int i = 0; i < NX_1; i++)        for (int j = 0; j < NY_1; j++)            res[i * NY_1 + j] = fabs(solution[i * NY_1 + j]                                     - analytical_solution_circle(tt, A + hx * i, C + hy * j));    return res;}double *get_exact_solution_5(double hx, double hy, double t) {    double *res = new double[XY];    for (int i = 0; i < NX_1; i++)        for (int j = 0; j < NY_1; j++)            res[i * NY_1 + j] = fabs(analytical_solution_circle(t, A + hx * i, C + hy * j));    return res;}